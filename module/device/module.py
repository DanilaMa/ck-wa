#
# Collective Knowledge (configure device)
#
# See CK LICENSE for licensing details
# See CK COPYRIGHT for copyright details
#
# Developer: dividiti, http://dividiti.com
#

cfg={}  # Will be updated by CK (meta description of this module)
work={} # Will be updated by CK (temporal data)
ck=None # Will be updated by CK (initialized CK kernel) 

# Local settings

##############################################################################
# Initialize module

def init(i):
    """

    Input:  {}

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """
    return {'return':0}

##############################################################################
# add connected device

def add(i):
    """
    Input:  {
              (data_uoa)      - CK entry name
              (data_name)     - user-friendly name

              (device_name)   - WA device name (generic_android, generic_linux, ... - see "wa list devices")

              (target_os)     - target OS on the device
              (device_id)     - device id if remote (such as adb)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """

    import os
    import json

    o=i.get('out','')

    # Load default config (in CK JSON)
    pm=work['path']
    p=os.path.join(pm, cfg['default_device_cfg_file'])

    r=ck.load_json_file({'json_file':p})
    if r['return']>0: return r
    dcfg=r['dict']

    # Choose CK alias for a given device (such as generic_linux, etc)
    duoa=i.get('data_uoa','')
    if duoa=='' and o=='con':
       r=ck.inp({'text':'Enter device alias for CK repository: '})
       duoa=r['string'].strip()

    # Choose CK user-friendly name
    dname=i.get('data_name','')
    if duoa=='' and o=='con':
       r=ck.inp({'text':'Enter user-friendly device name: '})
       dname=r['string'].strip()

    # Select WA device
    device=i.get('device_name','')
    if device=='' and o=='con':
       r=ck.inp({'text':'Enter WA device name (see "wa list devices") or press Enter for generic_android: '})
       device=r['string'].strip()
       if device=='': device='generic_android'

    # Check target OS and ID
    hos=i.get('host_os','')
    tos=i.get('target_os','')
    tdid=i.get('device_id','')

    # Updating default config
    dcfg['device']=device

    dd={'default_config':dcfg,
        'target_os':tos,
        'device_id':tdid}

    # Adding CK entry
    r=ck.access({'action':'add',
                 'module_uoa':work['self_module_uid'],
                 'data_uoa':duoa,
                 'data_name':dname,
                 'dict':dd,
                 'common_func':'yes'})
    if r['return']>0: return r

    # Generating config.py
    pp=r['path']
    px=os.path.join(pp,cfg['device_cfg_file'])

    s='# WA config file automatically generated by CK\n'
    for k in sorted(dcfg):
        s+=k+' = '

        v=dcfg[k]

        if type(v)==list or type(v)==dict:
           s+=json.dumps(v, indent=2, sort_keys=True)+'\n'
        elif type(v)==int or type(v)==float:
           s+=str(v)+'\n'
        else:
           s+='"'+str(v)+'"\n'

    # Trick (not clean) to replace true with True for python
    s=s.replace(' true', ' True')

    # Save config file in the new CK entry
    r=ck.save_text_file({'text_file':px, 'string':s})
    if r['return']>0: return r

    if o=='con':
       ck.out('CK entry and config file were successfully created in path '+pp)
       ck.out('  You can customize WA device config.py file there if needed!')

    return {'return':0}
